# 文档

[TOC]

## Router(路由)

路由用来注册处理句柄。cfcgi的提供HTTP 之 GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE、PATCH方法的路由注册。

通过`Group`方法来开启新的分组，但是这不是必须的。

```c++
FcgiRouter& Get(const std::string& path, FcgiHandlerPtr handler);
FcgiRouter& Post(const std::string& path, FcgiHandlerPtr handler);
FcgiRouter& Head(const std::string& path, FcgiHandlerPtr handler);
FcgiRouter& Options(const std::string& path, FcgiHandlerPtr handler);
FcgiRouter& Put(const std::string& path, FcgiHandlerPtr handler);
FcgiRouter& Delete(const std::string& path, FcgiHandlerPtr handler);
FcgiRouter& Trace(const std::string& path, FcgiHandlerPtr handler);
FcgiRouter& Patch(const std::string& path, FcgiHandlerPtr handler);

FcgiRouter& Group(const std::string& path, FcgiHandlerPtr handler);

```

```c++
void testHandler(FcgiContext& ctx) 
{
  ctx.Response.Out << "Hello, world";
}

void Init {
  // 普通路由
  Get("/hello", testHandler);
  Post("/hello", testHandler);
  
  // 分组路由
  Group("/v1");
  Get("/hello", [](FcgiContext& ctx) {});
  
  // 分组路由连写
  Group("/v2").Get("/hello", [](FcgiContext& ctx) {}).Post("/world", [](FcgiContext& ctx){});
  
  // 回到不分组状态
  Group("");
  Get("/world", [](FcgiContext& ctx) {});
}
```



## FcgiContext（上下文）

每个http请求对应一个`FcgiContext`上下文， 每个用户定义的处理函数都以`FcgiContext&`为参数。`FcgiContext`定义了一组非常方便的操作方法和成员。通过对这些方法和成员的访问，大大简化了用户编程。

<a name="SessionStart"></a>

### void SessionStart()

通过调用`SessionStart()`来开启会话，开启会话时会生成会话文件，会话id，并将会话id写入响应的cookie中。

```c++
void TestHandler(FcgiContext& ctx) {
  ctx.SessionStart();
  ctx.Response.Out << "session started.";
}
```

<a name="SessionDestroy"></a>

### void SessionDestroy()

通过调用`SessionDestroy()`来销毁当前会话。

```c++
void TestHandler(FcgiContext& ctx) {
  ctx.SessionDestroy();
  ctx.Response.Out << "session destroyed.";
}
```

### Redirect(const std::string& url)

`Redirect()`用来url重定向。注意此时不要包含响应内容。

参数`url`为要重定向的地址。

```c++
void TestHandler(FcgiContext& ctx) {
  ctx.Redirect("/login.html");
}
```

### CursorPtr GetDb(const std::string& driver, const DbParam& cfg)

`GetDb()`用来获取数据库处理句柄。

参数`driver`代表驱动名称，如`“mysql”`代表mysql数据库。

参数`cfcg`为数据库配置信息，详见[dbparam](#DbParam_) 。

返回数据库操作句柄指针，详见[Cursor](#Cursor) 。

```c++
void TestHandler(FcgiContext& ctx) {
  DbParam cfg {"127.0.0.1", "root", "123456", "test", "utf8", 3306};
  CursorPtr cursor = ctx.GetDb("mysql", cfg);
  bool bret = cursor.Query("show status");
  if (!bret) {
    ctx.Response.Err << "query failed.";
  }
  std::string col, col2;
  while (cursor.FetchRow({&col, &col2})) {
    ctx.Response.Out << col << ":\t\t" << col2 << "\n";
  }
}
```

### void Flush()

`Flush()`用来刷新`Response.Out`，调用该函数，会将响应的内容发送至web服务器端，这对于大文件传输很有用。默认只有在请求结束之前才将响应或错误发送至web服务端。

```c++
void TestHandler(FcgiContext& ctx) {
  ctx.Resopnse.Out << "hello, world";
  ctx.Flush();
  
  ctx.Response.Out << "another string";
  ctx.Flush();
}
```

### bool SaveFile(const std::string& src, const std::string& dest)

`SaveFile()`用来保存上传的文件，用户也可自定义保存文件的方法。SaveFile首先尝试通过Linux硬连接的方法来将临时文件移动到`dest`，如果失败，则使用文件拷贝。用法参考[文件上传](#Files)

### FcgiRequest Request

`ctx`的`Request`成员用来保存请求信息，Request负责解析并保存请求参数，以便用户访问。`Request`包含以下方法。

#### std::string& Uri()

`Uri()`获取用户请求的Uri，不包含Query参数。

返回Uri，如`/hello`。

```c++
void TestHandler(FcgiContext& ctx) {
  std::string uri = ctx.Request.Uri();
}
```



#### std::string& Query(const std::string& name)

`Query()`用来获取`GET`请求的参数。

参数`name`为参数的名称。

返回相应参数的值。

```c++
void TestHandler(FcgiContext& ctx) {
  std::string first_name = ctx.Request.Query("firstname");
  std::string last_name  = ctx.Request.Query("lastname");
  ctx.Response.Out << "Hello, " << first_name << " " << last_name;
}
```

#### std::string& PostForm(const std::string& name)

`PostForm()`用来获取`POST`请求的参数。

参数`name`为参数名称。

返回相应参数的值。

```c++
void TestHandler(FcgiContext& ctx) {
  std::string first_name = ctx.Request.PostForm("firstname");
  std::string last_name  = ctx.Request.PostForm("lastname");
  ctx.Response.Out << "Hello, " << first_name << " " << last_name;
}
```

#### FcgiValue& Header(const std::string& name)

`Header()`用来获取请求头，实际上，所有的`fast_params`都可以通过该函数来获取，其值为`FcgiValue&`类型，

您可以调用其方法`AsString()`和`AsInt()`来分别获取string和int值，需要注意的是，您请求您所获取的参数是和类型，否则可能会获取不到值。

```c++
void TestHandler(FcgiContext& ctx) {
  std::string content_type 	= ctx.Request.Header("content_type").AsString();
  int 		content_length 	= ctx.Request.Header("content_length").AsInt();
}
```

#### std::string& Body()

`Body()`用来获取请求的原始的body。

返回请求body。

```c++
void TestHandler(FcgiContext& ctx) {
  ctx.Response.Out << ctx.Request.Body();
}
```

#### std::string& RemoteAddr()

`RemoteAddr()`用来获取远端地址。也可以调用`Header("remote_addr")`来获取。

返回客户端地址。注意这里remote_addr不一定准确，很有可能获取的是上一跳路由器的地址。

```c++
void TestHandler(FcgiContext& ctx) {
  std::string& remote  = ctx.Request.RemoteAddr();
  std::string& remote2 = ctx.Request.Header("remote_addr");
  ctx.Response.Out << remote << ", " << remote2;
}
```



#### std::string& ContentType()

`ContentType()`用来获取请求类型。也可以调用`Header("content_type")`来获取。

返回请求mime类型。也有可能返回空值。

```c++
void TestHandler(FcgiContext& ctx) {
  std::string& content_type = ctx.Request.ContentType();
  std::string content_type2 = ctx.Request.Header("content_type");
}
```

#### const int& Method()

`Method()`返回请求方法。它是一个枚举类型的成员，定义如下。

```c++
enum {
  	GET,
    POST,
    PUT,
    DELETE,
    HEAD,
    OPTIONS,
    TRACE,
    PATCH
};
```

```c++
void TestHandler(FcgiContext& ctx) {
  int method = ctx.Request.Method();
  int method2 = ctx.Request.Header("");
}
```

#### unsigned int& ContentLength()

`ContentLength()`用来获取请求长度。也可以调用`Header("content_length")`来获取。

返回请求长度。

```c++
void TestHandler(FcgiContext& ctx) {
  int content_length  = ctx.Request.ContentLength();
}
```

#### FcgiCookie& Cookie()

`Cookie()`返回请求的Cookie。详见[Cookie](#Cookie).

```c++
void TestHandler(FcgiContext& ctx) {
  std::string cookie = ctx.Request.Cookie().Get("csessionid");
}
```

<a name="Files"></a>

#### std::vector &lt; FileChunk*&gt; Files() 文件上传 (multipart/form-data)

`Files()`用来获取上传的文件信息。`cfcgi`会将文件存放在临时路径，请求结束后会自动删除临时文件。

```c++
class FileChunk {
public:
  std::string     m_fileName;		// 文件名（不含路径）
  std::string     m_contentType;	// 文件类型
  std::string     m_name;			// 表单项中的名称(<input type="file" name="xxx">)
  std::string     m_filePath;		// 文件临时存放路径
  std::string     m_boundary;		// 文件boundary
};
```

用户可调用`ctx.SaveFile()`方法来保存文件。

```c++
void TestHandler(FcgiContext& ctx) {
  std::string destdir = "/tmp/haha/";
  std::vector<FileChunk*> finfos = ctx.Request.Files();
  for (auto f : finfos) {
    std::string dest = destdir + f->m_fileName;
    ctx.SaveFile(f->m_filePath, dest);
  }
}
```

### FcgiResponse Response

`Response`存储响应相关数据，其包含以下成员及方法。

#### void Header(const std::string& name, const std::string& value);

`Header`用来设置响应头。

参数`name`是头名称

参数`value`是其值，不需要加`\r\n`。

```c++
void Hello(FcgiContext& ctx) {
  ctx.Response.Header("content-type", "application/json");
  ctx.Response.Out << "{\"ret\":" << 0 << ", \"msg\":\"" << "success" << "\"}";
}
```

#### FcgiCookie& Cookie()

`Cookie()`方法用来获取响应的Cookie，从而设置相应Cookie。详见[Cookie](#Cookie)

```c++
void Hello(FcgiContext& ctx) {
  ctx.Response.Cookie().Set("hello=world");
}
```

#### std::stringstream Out

`Out`是一个输出流，通过`<<`操作用来写响应。不过此时的响应并不会真正的发送到web服务器，如果需要立即发送到web服务器，请调用`ctx`的`Flush()`方法。

```c++
void Hello(FcgiContext& ctx) {
  ctx.Response.Out << "Hello, world";
  
  // 调用Flush(), 立即发送响应
  ctx.Flush();
}
```

#### std::stringstream Err

`Err`是一个错误流，通过`<<`操作来写入错误信息，通常，该信息会被记载在web服务器的error日志中。

用户不需要手动来设置`ctx`的`Status`，除非希望设置`500`之外的值。

```c++
void TestHandler(FcgiContext& ctx) {
  ctx.Response.Err << "Ooops, somthing has gone";
}
```

### FcgiSession Session

`Session`用来管理会话。`FcgiSession`继承自[FcgiObject](#FcgiObject)可以通过[FcgiObject](#FcgiObject)的相关方法来使用`Session`.

通过调用`ctx`的[SessionStart()](#)来开启一个会话，通过调用`ctx`的[SessionDestroy()](#SessionDestroy)来销毁会话。

#### const std::string& GetID()

`GetID()`用来获取会话ID。调用该方法前，需确保会话已经开始。

```c++
void TestHandler(FcgiContext& ctx) {
  ctx.SessionStart();
  std::string session_id = ctx.Session.GetID();
}
```

#### void SetExpires(int expire)

`SetExpires()`用来设置会话的过期时间，单位为秒，调用该方法前，需确保会话已经开始。

```c++
void TestHandler(FcgiContext& ctx) {
  ctx.SessionStart();
  ctx.Session.SetExpires(3600);
}
```

### int Status

`Status`为响应码，`200`为`成功`,其他值为失败。具体参见[RFC2616](https://www.rfc-editor.org/rfc/rfc2616.txt) 。

### SimpleLog::Logger::LoggerPtr Log

`Log`用于打印日志。 **以下日志方法，都不会添加换行。**

#### void Fatal(const char* fmt, ...)

```c++
void TestHandler(FcgiContext& ctx) {
  ctx.Log->Fatal("Fatal error\n");
}
```

#### void Alert(const char* fmt, ...)

```c++
void TestHandler(FcgiContext& ctx) {
  ctx.Log->Alert("Alert error\n");
}
```

#### void Err(const char* fmt, ...)

```C++
void TestHandler(FcgiContext& ctx) {
  ctx.Log->Err("Err error\n");
}
```

#### void Warn(const char* fmt, ...)

```c++
void TestHandler(FcgiContext& ctx) {
  ctx.Log->Warn("Warn log\n");
}
```

#### void Info(const char* fmt, ...)

```c++
void TestHandler(FcgiContext& ctx) {
  ctx.Log->Info("Info log\n");
}
```

#### void Debug(const char* fmt, ...)

```c++
void TestHandler(FcgiContext& ctx) {
  ctx.Log->Debug("Debug log\n");
}
```

<a name="DbParam"></a>

## DbParam

```c++
struct DbParam {
    std::string host;
    std::string user;
    std::string password;
    std::string dbname;
    std::string charset;
    unsigned short port;
};
```

`DbParam`定义了数据连接的结构。

<a name="Cursor"></a>

## Cursor

`Cursor`为数据库处理句柄。定义了一些常用的关系型数据库操作接口。

<a name="RowType"></a>

### RowType

`RowType`定义了数据结果集的行类型。结果集的每一列都为字符串类型的指针。

```c++
typedef std::initializer_list<std::string*> RowType;
```

<a name="BindList"></a>

### BindList

`BindList`为绑定参数查询时，参数列表的类型。只支持绑定`int`,`string`,`double`类型。

```c++
typedef std::variant<int, double, std::string> BindType;
typedef std::initializer_list<BindType> BindList;
```

### bool TransBegin()

`TransBegin()`用来开启一个事物，通常不需要手动`Commit()`或`Rollback()` 。

成功返回`true` ，失败返回`false` 。

```c++
void TestHandler(FcgiContext& ctx) {
  DbParam cfg {"127.0.0.1", "root", "123456", "test", "utf8", 3306};
  CursorPtr cursor = ctx.GetDb("mysql", cfg);
  if (!cursor->TransBegin()) {
    ctx.Response.Err << "start transaction failed.";
    return;
  }
}
```

### bool Commit()

`Commit()`用来提交一个事物，开启事物后，如果没有主动提交，在请求结束前，系统会主动提交为提交的事物。

```c++
void TestHandler(FcgiContext& ctx) {
  DbParam cfg {"127.0.0.1", "root", "123456", "test", "utf8", 3306};
  CursorPtr cursor = ctx.GetDb("mysql", cfg);
  if (!cursor->TransBegin()) {
    ctx.Response.Err << "start transaction failed.";
    return;
  }
  
  bool bret = cursor->Query("insert into tb_test values (%d, %d, %d)", 1, 2, 3);
  if (!bret) {
    ctx.Response.Err << "query failed.";
    return;
  }
  
  // Commit
  cursor->Commit();
}
```

### bool Rollback()

`Rollback()`用于事务回滚，仅当未提交时才能条用该方法。

```c++
void TestHandler(FcgiContext& ctx) {
  DbParam cfg {"127.0.0.1", "root", "123456", "test", "utf8", 3306};
  CursorPtr cursor = ctx.GetDb("mysql", cfg);
  if (!cursor->TransBegin()) {
    ctx.Response.Err << "start transaction failed.";
    return;
  }
  
  // ... 一些操作 ...
  
  cursor->Rollback();
}
```

<a name="Query"></a>

### bool Query(const char* sql, ...)

`Query()`方法用来执行数据库操作。cfcgi的mysql驱动提供两种方法来执行sql，一种是`Query()`一种是[QueryBind()](#QueryBind) 。

参数`sql`是`c`格式参数列表的`format`字符串。

参数`...`为`c`格式参数列表，非必须。

成功返回`true`， 失败返回`false`

```c++
void TestHandler(FcgiContext& ctx) {
  DbParam cfg {"127.0.0.1", "root", "123456", "test", "utf8", 3306};
  CursorPtr cursor = ctx.GetDb("mysql", cfg);
 
  bool bret = cursor->Query("insert into tb_test values (%d, %d, %d)", 1, 2, 3);
  if (!bret) {
    ctx.Response.Err << "query failed.";
    return;
  }
}
```

<a name="QueryBind"></a>

### bool QueryBind(const std::string& sql, const BindList& params)

`QueryBind()`是另一种执行数据库操作的方法，与[Query()](#Query)不通的是，该方法会调用`stmt`api来执行sql语句。驱动会缓存已经`prepare`过的`stmt`句柄。在下次调用时，会直接去除该句柄来执行sql语句。理论上`QueryBind`的效率应该要比[Query()][#Query]高效（减少服务器解析sql语句的次数），但实际结果并不一定这样。因为在cfcgi的mysql驱动中，每次取结果行都调用绑定参数（相同列的长度不尽相同，并非是表定义时的长度）。

```c++
void TestHandler(FcgiContext& ctx) {
  DbParam cfg {"127.0.0.1", "root", "123456", "test", "utf8", 3306};
  CursorPtr cursor = ctx.GetDb("mysql", cfg);
 
  bool bret = cursor->QueryBind("insert into tb_test values (?,?,?)", {1, "hello", 3.00});
  if (!bret) {
    ctx.Response.Err << "query failed.";
    return;
  }
}
```

### bool FetchRow(RowType row)

`FetchRow()`用来获取结果集，每次调用获得一行结果。

参数`row`为获取的结果集行。注意参数row的成员必选是字符串指针，且不能为空。

成功返回`true`, 失败返回`false` 。

```c++
void TestHandler(FcgiContext& ctx) {
  DbParam cfg {"127.0.0.1", "root", "123456", "test", "utf8", 3306};
  CursorPtr cursor = ctx.GetDb("mysql", cfg);
 
  // query
  bool bret = cursor->QueryBind("select ?, ? union all select ?, ?", {1234, "hello", 567890, "world"});
  if (!bret) {
    ctx.Response.Err << "query failed.";
    return;
  }
  
  // fetch result
  std::string col, col2;
  while (cursor->FetchRow({&col, &col2})) {
    ctx.Response.Out << "col one: " << col << ", col two: " << col2 << endl;
  }
  
  bool bret = cursor->Query("select 'hello', 'world' union all select '123456', '78890'");
  if (!bret) {
    ctx.Response.Err << "query failed";
    return;
  }
  
  // fetch result
  std::string col, col2;
  while (cursor->FetchRow({&col, &col2})) {
    ctx.Response.Out << "col one: " << col << ", col two: " << col2 << endl;
  }
}
```

### size_t FieldCount()

`FieldCount()` 用来获取结果集列数。

返回列数。

`size_t columns = cursor->FieldCount();`

### bool NextResult()

`NextResult()`用于多结果集的场合，用来切换到下一个结果集。

成功返回`true`，失败返回 `false` 。

```c++
void TestHandler(FcgiContext& ctx) {
  DbParam cfg {"127.0.0.1", "root", "123456", "test", "utf8", 3306};
  CursorPtr cursor = ctx.GetDb("mysql", cfg);
  
  // cfcgi的mysql驱动支持多状态，所以能一次执行多条sql语句。
  bool bret = cursor->Query("select 'hello'; select 'world'");
  if (!bret) {
    ctx.Response.Err << "query failed.";
    return;
  }
  
  do {
  	std::string col;
 	ctx.Reponse.Out << "result sets: " << endl;
    while (cursor->FetchRow({&col})) {
      ctx.Response.Out << "\t" << col << endl;
    }
  } while (cursor->NextResult());
}
```



<a name="Cookie"></a>

## Cookie

cfcgi支持cookie管理。

### void Set(...)

`Set()`的原型如下:

```c++
void Set(const std::string& cookie, const std::string& expires = "",
             const std::string& domain = "", const std::string& path = "/",
             const bool& httponly = true);

void Set(const std::vector<std::string>& names, const std::vector<std::string>& values,
             const std::string& expires = "", const std::string& domain = "",
             const std::string& path = "/", const bool& httponly = true);
```

第一个用来设置单个cookie，第二个用来一次设置多个cookie。

`cookie`: 表示要设置的cookie值，`key=value`格式。

`expires`: 表示过期时间。

`domain`: 表示缓存的域，如"www.baidu.com"。

`path`: 缓存有效路径，默认为全网站有效"/"。

`httponly`:如果设置该项，则前端不能通过`javascript`获取该缓存。

`names`: 表示要设置的cookie的名称列表。

`values`: 表示要设置的cookie的值列表，names和values一一对应。

```c++
void TestHandler(FcgiContext& ctx) {
  ctx.Response.Cookie().Set("csessionid=12341234123412341234");
  ctx.Response.Cookie().Set({"user", "expires", "last-login-time"},
                            {"guest", "3600", "2019-06-01 10:20:30"});
}
```

### std::string Get(const std::string& name)

`Get()` 用来获取相应的缓存值。

`name`为缓存的名称。

返会缓存值。

```c++
void TestHandler(FcgiContext& ctx) {
  std::string session_id = ctx.Request.Cookie().Get("csessionid");
}
```

<a name="FcgiObject"></a>

## FcgiObject

### ObjectValue

`ObjectValue`为值`FcgiObject`的值类型，允许的值有: int, double, std::string, FcgiObject及其数组。

ObjectValue定义的一些类型：

```c++
typedef std::vector<int> intarray;
typedef std::vector<std::string> strarray;
typedef std::vector<double> floatarray;
typedef std::vector<FcgiObject*> objarray;

typedef std::variant<int, double, std::string> InputDataType;
typedef std::tuple<std::string, InputDataType> KeyValueType;
typedef std::tuple<std::string, std::initializer_list<std::string>> KeyStrList;
typedef std::tuple<std::string, std::initializer_list<int>> KeyIntList;
typedef std::tuple<std::string, std::initializer_list<double>> KeyFloatList;
typedef std::tuple<std::string, std::initializer_list<KeyValueType>> KeyObjList;
```

允许的构造函数：

```c++
ObjectValue(const int& v);
ObjectValue(const double& v);
ObjectValue(const std::string& v);
ObjectValue(const intarray& v);
ObjectValue(const strarray& v);
ObjectValue(FcgiObject* v);
ObjectValue(const floatarray& v);
ObjectValue(const objarray& v);
```

`ObjectValue`还定义了一些类型转换操作，从而确保可以将ObjectValue的值直接赋值给其所支持的类型。

```c++
operator int() const;
operator double() const;
operator std::string&() const;
operator FcgiObject* () const;

operator intarray() const;
operator floatarray() const;
operator strarray() const;
operator objarray() const;
```

```c++
ObjectValue *obj;
// 一些初始化相关操作

int a = *obj;
double b = *obj;
std::string& s = *obj;
FcgiObject *fo = *obj;

intarray aa   = *obj;
floatarray ab = *obj;
strarray as   = *obj;
objarray ao   = *obj;
```

**注意：**`ObjectValue`语义上不支持二维及以上的数组，以后增加支持。

另外ObjectValue还支持数组和FcgiObject的`[]`操作。

### _F()

`_F()`为一组转发函数，简化FcgiObject构造数组值。这里没有定义KeyFloatLis类型的转发，因为这会和KeyIntList产生二义性。

```c++
const ObjectValue::KeyIntList& _F(const ObjectValue::KeyIntList& x);
const ObjectValue::KeyStrList& _F(const ObjectValue::KeyStrList& x);
const ObjectValue::KeyObjList& _F(const ObjectValue::KeyObjList& x);
```

例如：

```c++
_F({"key", {"hello", "world"}});
_F({"key2", {1, 2, 3, 4} });
_F({"key3", {{{"obj1key1", "obj1value1"}, {"obj1key2", "obj1value2"}}, {{"obj2key1", "obj2value1"}, {"obj2key2", "obj2value2"}}} });
```

### _K

`_K`为`KeyValueType`类型的别名，避免直接通过初始化列表那样写时带来的二义性（KeyValueType与string List）。

例如：

```c++
_K{"hello", "world"}
```

### <<

输出流操作：

```c++
std::ostream& operator<<(std::ostream& o, const FcgiObject& v);
std::ofstream& operator<<(std::ofstream& o, const FcgiObject& v); 
```

`std::ostream& operator<<(std::ostream& o, const FcgiObject& v)`将以json字符串的形式将FcgiObject写入到ostream中。即json序列化。

`std::ofstream& operator<<(std::ofstream& o, const FcgiObject& v)`会将FcgiObject以二进制的形式写入到文件。

### >>

输入流操作：

```c++
std::istream& operator>>(std::istream& o, FcgiObject& v);
std::ifstream& operator>>(std::ifstream& o, FcgiObject& v);
```

`std::istream& operator>>(std::istream& o, FcgiObject& v)`用于从json字符串中解析json。

`std::ifstream& operator>>(std::ifstream& o, FcgiObject& v)`用于从二进制文件中解析json。

### +

```c++
FcgiObject& FcgiObject::operator+(const std::string& key);
```

`+` 用于向FcgiObject中增加一个子Object，其类型也是也是FcgiObject格式，但是会返回**新增加**对象的引用。

### -

```c++
// add key values, return current object
FcgiObject& FcgiObject::operator-(const ObjectValue::KeyValueType& kv);
FcgiObject& FcgiObject::operator-(const ObjectValue::KeyStrList& kvs);
FcgiObject& FcgiObject::operator-(const ObjectValue::KeyIntList& kvs);
FcgiObject& FcgiObject::operator-(const ObjectValue::KeyFloatList& kvs);
FcgiObject& FcgiObject::operator-(const ObjectValue::KeyObjList& kvs);
```

`-`用于向当前FcgiObject中增加子元素，并返回当前FcgiObject对象的引用。

例如：

```c++
FcgiObject obj;
obj - _K{"hello", "world"}
	- _F({"haha", {"this", "is", "an", "array", "with", "string", "type"}});
```

### []

```c++
ObjectValue& FcgiObject::operator[](const std::string& key);
```

`[]`用来获取值。

```c++
void TestHandler(FcgiContext& ctx) {
  FcgiObject obj;
  // 插入一些值
  obj - _K{"hello", "world"}
  	  + "sub"
        - K{"user", "admin"}
  		- K{"roles", {"admin", "reader", "writer"}}
  // 获取一些值
  std::string hello = obj["hello"];				// hello = world
  std::string user  = obj["sub"]["user"];	 	// user = admin
  std::string role0 = obj["sub"]["roles"][1]; 	// role0 = reader
}
```

## FcgiXml

终于增加了xml解析。

### FcgiXml::operator std::string() const

强制类型转换用来获取FcgiXml的值，此时FcgiXml无子节点，否则返回空。

此处把xml的所有节点的值都当成是字符串类型。

### []

`[]`操作用来获取子节点，其原型如下：

```c++
FcgiXml& FcgiXml::operator[](const std::string& key);
```

参数`key`为子节点的名称。

返回子节点对象。

### attr

`attr`用来存放xml的属性值，是一个数组(vector)。

```
struct XmlAttr {
    std::string name;
    std::string value;
};

struct XmlAttrVec {
    std::vector<XmlAttr> m_attr;
    std::string& operator[](const std::string& name);
};

XmlAttrVec attr;
```

这里重新定义了`[]`以方便通过属性名来获取属性值。

### <<

`<<`用来将FcgiXml结构序列化为xml字符串。其原型如下:

```c++
std::ostream& operator<<(std::ostream&, const FcgiXml&);
```

### >>

`>>`用来解析xml字符串为FcgiXml对象。其原型如下：

```c++
std::istream& operator>>(std::istream&, FcgiXml&);
```

一个xml解析的例子：

```c++
void TestHandler(FcgiContext& ctx) {
    const char* xmlstr = "<?xml encoding=\"utf8\" ?>\n"
                         "<Request>\n"
                         "<hello>hello world</hello>\n"
                         "<user expires=\"3600\" logtime=\"2019-07-10 12:20:30\">\n"
                         "<name>guest</name>\n"
                         "<logo>/images/user/guest.png</logo>\n"
                         "<hahaha>test data hahaha</hahaha>\n"
                         "</user>\n"
                         "<test-signal-label a=\"1\" b=\"2\" />\n"
                         "</Request>";
    FcgiXml myXml;
    std::istringstream iss(xmlstr);
    iss >> myXml;

    std::cout << (std::string)myXml["hello"] << std::endl;
    std::cout << (std::string)myXml["user"]["name"] << std::endl;
    std::cout << (std::string)myXml["user"]["logo"] << std::endl;
    std::cout << (std::string)myXml["test-signal-label"].attr["a"] << std::endl;;
    std::cout << myXml << std::endl;
}
```

