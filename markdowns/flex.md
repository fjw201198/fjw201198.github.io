# Flex

格式：

```
definitions
%%
rules
%%
user code
```

文件由"%%"分隔的三部分的组成。

## 定义区域 （definitions section)

定义区域包含简单名称的定义的声明。

格式如下：

```
名称 定义
```

名称以字母或下划线开头，后面跟字母、下划线、数字或'-'(dash).

定义由飞空白字母开头，换行结束。引用时使用`{名称}`的格式。

如：

```
DIGIT [0-9]
ID	  [a-z][a-z0-9]*
```

引用格式：

```
{DIGIT}+"."{DIGIT}*
```

等价于：

```
([0-9])+"."([0-9])*
```

定义区和规则区的任何缩进的文本或包含在’%{‘ 和 ’%}‘之间的文本将会复制到输出。注意%{和%}不能缩进。

定义去缩进的注释(/* */)也会被复制到输出中。

## 规则区域

出现在第一条规则之前的任何缩进的文本 或 %{和%}之间的文本可被用来声明变量。其他地方的竟会被复制到输出中。

当有多个规则匹配时，优先使用最长的匹配，如果有多个相同长度的匹配时，则会选择第一个列出的。

一旦决定了匹配，TOKEN将会保存在全局指针yytext（char *）中。TOKEN的长度保存在全局变量yyleng中，

接着，匹配的action将会被执行。

如果为发现匹配，则会执行默认的规则：拷贝输出下一个字符。

**注意** ，yytext有两种定义方式：字符指针和字符数组。可以通过在定义区中加入指令`%pointer`或`%array`来控制，默认是`%pointer`,除非使用lex兼容选项(`-l`),兼容模式下将使用数组。使用指针的优势是：

-   更快的扫描；
-   匹配长的TOKEN时不会有缓冲区溢出。

`%pointer`的劣势（`%array`的优势）是：

-   不能修改yytext
-   调用unput()时会销毁当前yytext的内容。



## 模式匹配

| 模式             | 描述                                       |
| -------------- | ---------------------------------------- |
| 'x'            | 匹配字符’x'                                  |
| '.'            | 除换行外任意字符（字节)                             |
| '[xyz]'        | 一类字符，本例中为匹配x或y或z                         |
| '[abj-oZ]'     | 一类字符，匹配范围，a,b,j ~ o, Z                   |
| `'[^A-Z]'`     | ^为取反之意                                   |
| 'r*'           | 0或更多的r                                   |
| 'r+'           | 一个或更多的r                                  |
| 'r?'           | 0或一个r                                    |
| 'r{2,5}'       | 2到5个r                                    |
| 'r{2,}'        | 至少2个r                                    |
| 'r{4}'         | 4个r                                      |
| '{name}'       | 扩展'name'的定义                              |
| '"[xyz]\"foo"' | [xyz]"foo                                |
| '\x'           | 转义字符。                                    |
| '\0'           | NUL字符，ASCII 码 0.                         |
| '\123'         | 八进制字符                                    |
| '\x2a'         | 十六进制字符                                   |
| '(r)'          | 匹配r,括号用来表示优先级                            |
| 'rs'           | 匹配正在r后面跟着正则s，即合并                         |
| 'r\|s'         | 匹配r或s                                    |
| 'r/s'          | r，但是后面不是s                                |
| `'^r'`         | 行首r                                      |
| `'r$'`         | 行尾r                                      |
| `'<s>r'`       | s开始的r                                    |
| '<*>r'         | 任意开始的r，甚至前面不包含任何字符                       |
| `'<<EOF>>'`    | end-of-file, 如 `<s1,s2><<EOF>>` s1或s2开始的end-of-file |
|                |                                          |

**注意** []内的任何正则表达式操作符将实效，除了'\'、'-',']'后开始的'^'。

列出的正则表达式根据优先级分组。高的优先级在前面，低的优先级在后面。

如:

```
foo|bar*
```

等价于:

```
(foo)|(ba(r*))
```

而不是:

```
(foo)|(bar)*
```

因为’*‘比合并的优先级高，合并比'|'的优先级高。

以下简化的定义需要包含在`[]`内：

`[:alnum:]`, `[:alpha:]`,`[:blank:]`,`[:cntrl:]`,`[:digit:]`,`[:graph:]`,`[:lower:]`,

`[:print:]`,`[:punct:]`,`[:space:]`,`[:upper:]`,`[:xdigit:]`

下面这些模式等价：

```
[[:alnum:]]
[[:alpha:][:digit:]]
[[:alpha:]0-9]
[a-zA-Z0-9]
```

注意：

-   `[^]`的形式可能会包含`\n`，除非`\n`在`[^]`中。

-   一个规则中最多包含一个结尾符（`/`或`$`）。

-   `^`和`<<EOF>>`只能出现在模式的开始；`/`和`$`不能出现圆括号内。

-   `^`不能出现在规则的开始，`$`不能出现在规则的末尾，否则会被当成普通字符。

    下面的格式将是非法的：

    ```
    foo/bar$
    <sc1>foo<sc2>bar
    ```

    第一个可以写成`foo/bar\n`.

    下面的`$`和`^`将被当作普通字符:

    ```
    foo|(bar$)
    foo|^bar
    ```

    下面情况可以工作:

    ```
    foo 	|
    bar$	/* action goes here */
    ```

## Actions

actions可以是任何C语句,包括return语句，返回值会在每次调用`yylex()`时返回。多行语句需要包含在`{}`内。

如果action为空，则匹配的模式将被丢弃。

action包含单个`|`表示和下个规则相同的action，如:

```
%%
a		|
ab		|
abcd	ECHO; REJCT;

```

使用指针模式时，在不改变yytext的长度情况下，可以任意的修改yytext。

在数组模式下，可以任何形式的修改yytext。

action中使用`yymore()`不能修改yyleng。

action中可以使用一些指令：

-   `ECHO`: 拷贝yytext到输出。
-   `BEGIN`： 

